package hosts

import (
	"bufio"
	"bytes"
	"fmt"
	"net"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/dimchansky/utfbom"
	"github.com/freshwebio/cloud-uno/pkg/config"
)

const cloudUnoComment = "Generated by Cloud::1"

// Manager provides a service that deals with managing
// hosts on the host machine as a part of cloud DNS emulation.
// Manager is designed to be invoked by RPC, so all the arguments
// are pointers to primitive data types.
type Manager struct {
	Path    string
	Entries []Entry
}

// NewManager creates a new instance of a service that deals with managing
// os-level hosts on a machine.
func NewManager(cfg *config.Config) (Service, error) {
	osHostsFilePath := os.ExpandEnv(filepath.FromSlash(HostsFilePath))
	if *cfg.HostsPath != "" {
		osHostsFilePath = os.ExpandEnv(filepath.FromSlash(*cfg.HostsPath))
	}

	mgr := &Manager{
		Path:    osHostsFilePath,
		Entries: []Entry{},
	}
	if err := mgr.load(); err != nil {
		return mgr, err
	}
	return mgr, nil
}

func (m *Manager) load() error {
	file, err := os.Open(m.Path)
	if err != nil {
		return err
	}
	defer file.Close()
	scanner := bufio.NewScanner(utfbom.SkipOnly(file))
	for scanner.Scan() {
		m.Entries = append(m.Entries, NewEntry(scanner.Text()))
	}
	if err := scanner.Err(); err != nil {
		return err
	}
	return nil
}

func (m *Manager) getIPPosition(ip string) int {
	for i := range m.Entries {
		entry := m.Entries[i]
		if !entry.IsComment() && entry.Raw != "" && entry.IP == ip {
			return i
		}
	}

	return -1
}

// Add one or more host entries.
func (m *Manager) Add(ip *string, hosts *string) error {
	if net.ParseIP(*ip) == nil {
		return fmt.Errorf("%q is an invalid IP address", *ip)
	}
	hostsList := strings.Split(*hosts, ",")

	position := m.getIPPosition(*ip)
	if position == -1 {
		// ip not already in hostsfile
		m.Entries = append(m.Entries, Entry{
			Raw:     buildRawLine(*ip, hostsList),
			IP:      *ip,
			Hosts:   hostsList,
			Comment: cloudUnoComment,
		})
	} else {
		// add new hosts to the correct position for the ip
		hostsCopy := m.Entries[position].Hosts
		for _, addHost := range hostsList {
			if itemInSlice(addHost, hostsCopy) {
				continue // host exists for ip already
			}

			hostsCopy = append(hostsCopy, addHost)
		}
		m.Entries[position].Hosts = hostsCopy
		m.Entries[position].Raw = m.Entries[position].Export() // reset raw
	}
	m.clean()
	// Each host can only be configured to work for a single IP at a time,
	// to ensure the provided IP is used we need to make sure
	// we clear all other references to the same hosts.
	m.removeHostsFromOtherIPs(*ip, hostsList)
	err := m.flush()
	return err
}

// Remove one or more host entries.
func (m *Manager) Remove(ip *string, hosts *string) error {
	var outputEntries []Entry
	hostsList := strings.Split(*hosts, ",")
	if net.ParseIP(*ip) == nil {
		return fmt.Errorf("%q is an invalid IP address", *ip)
	}

	for _, entry := range m.Entries {
		// Bad lines or comments just get readded.
		if entry.Err != nil || entry.IsComment() || entry.IP != *ip {
			outputEntries = append(outputEntries, entry)
			continue
		}

		var newHosts []string
		for _, checkHost := range entry.Hosts {
			if !itemInSlice(checkHost, hostsList) {
				newHosts = append(newHosts, checkHost)
			}
		}

		// If hosts is empty, skip the line completely.
		if len(newHosts) > 0 {
			newLineRaw := entry.IP

			for _, host := range newHosts {
				newLineRaw = fmt.Sprintf("%s %s", newLineRaw, host)
			}
			newEntry := NewEntry(newLineRaw)
			outputEntries = append(outputEntries, newEntry)
		}
	}

	m.Entries = outputEntries
	m.clean()
	err := m.flush()
	return err
}

func (m *Manager) removeHostsFromOtherIPs(keepForIP string, hosts []string) {
	for _, host := range hosts {
		for pos, entry := range m.Entries {
			if itemInSlice(host, entry.Hosts) && entry.IP != keepForIP {
				entry.Hosts = removeFromSlice(host, entry.Hosts)
			}
			m.Entries[pos] = entry
		}
	}
}

func (m *Manager) clean() {
	m.removeDuplicateIps()
	for pos, entry := range m.Entries {
		entry.RemoveDuplicateHosts()
		entry.SortHosts()
		m.Entries[pos] = entry
	}
	m.sortByIP()
	m.hostsPerLine(HostsPerLine)
}

func (m *Manager) hostsPerLine(count int) {
	if count <= 0 {
		return
	}
	var newEntries []Entry
	for _, entry := range m.Entries {
		if len(entry.Hosts) <= count {
			newEntries = append(newEntries, entry)
			continue
		}

		for i := 0; i < len(entry.Hosts); i += count {
			entryCopy := entry
			end := len(entry.Hosts)
			if end > i+count {
				end = i + count
			}
			entryCopy.Hosts = entry.Hosts[i:end]
			entryCopy.Raw = entryCopy.Export()
			newEntries = append(newEntries, entryCopy)
		}
	}
	m.Entries = newEntries
}

func (m *Manager) sortByIP() {
	sortedIps := make([]net.IP, 0, len(m.Entries))
	for _, entry := range m.Entries {
		sortedIps = append(sortedIps, net.ParseIP(entry.IP))
	}
	sort.Slice(sortedIps, func(i, j int) bool {
		return bytes.Compare(sortedIps[i], sortedIps[j]) < 0
	})

	var sortedEntries []Entry
	for _, ip := range sortedIps {
		for _, entry := range m.Entries {
			if ip.String() == entry.IP {
				sortedEntries = append(sortedEntries, entry)
			}
		}
	}
	m.Entries = sortedEntries
}

func (m *Manager) removeDuplicateIps() {
	ipCount := make(map[string]int)
	for _, entry := range m.Entries {
		ipCount[entry.IP]++
	}
	for ip, count := range ipCount {
		if count > 1 {
			m.combineIP(ip)
		}
	}
}

func (m *Manager) combineIP(ip string) {
	newEntry := Entry{
		IP: ip,
	}

	entriesCopy := make([]Entry, len(m.Entries))
	copy(entriesCopy, m.Entries)
	for _, entry := range entriesCopy {
		if entry.IP == ip {
			newEntry.Combine(entry)
		}
	}
	newEntry.SortHosts()
	m.removeIP(ip)
	m.Entries = append(m.Entries, newEntry)
}

func (m *Manager) removeIP(ip string) {
	var newEntries []Entry
	for _, entry := range m.Entries {
		if entry.IP != ip {
			newEntries = append(newEntries, entry)
		}
	}

	m.Entries = newEntries
}

// Flush any changes made to the hosts file.
func (m *Manager) flush() error {
	file, err := os.Create(m.Path)
	if err != nil {
		return err
	}

	defer file.Close()

	w := bufio.NewWriter(file)

	for _, entry := range m.Entries {
		if _, err := fmt.Fprintf(w, "%s%s", entry.Export(), eol); err != nil {
			return err
		}
	}

	err = w.Flush()
	if err != nil {
		return err
	}

	return m.load()
}
